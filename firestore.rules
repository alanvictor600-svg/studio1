/**
 * @fileoverview Firestore Security Rules for the Bol√£o Potiguar app.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model. Each user has exclusive access to their profile data and associated tickets.
 * Public data like draws are readable by any authenticated user.
 *
 * Data Structure:
 * - User profiles are stored in `/users/{userId}`.
 * - Each user's lottery tickets are stored in `/users/{userId}/tickets/{ticketId}`.
 * - Draws are stored in `/draws/{drawId}`.
 *
 * Key Security Decisions:
 * - Users can only read and write their own data, enforced through path-based matching and the `isOwner()` function.
 * - Listing of tickets is restricted to the owner of the tickets.
 * - Draws are public to all signed-in users but writable only by admins (simulated here by disallowing client writes).
 * - Users are identified using their Firebase Auth UID, which must match the `userId` in the Firestore paths.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     */
    match /users/{userId} {
      function isOwner() {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && (isOwner() || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
      allow list: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'; // Allow admins to list users
      // Allow creation if the user ID in the path matches the authenticated user's ID
      // This resolves a race condition during sign-up where isSignedIn() might be false briefly.
      allow create: if request.auth.uid == userId && request.resource.data.id == userId;
      allow update: if isSignedIn() && (isOwner() || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
      allow delete: if isSignedIn() && (isOwner() || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
    }

    /**
     * @description Controls access to ticket documents under a user's profile.
     * @path /users/{userId}/tickets/{ticketId}
     */
    match /users/{userId}/tickets/{ticketId} {
      function isOwner() {
        return request.auth.uid == userId;
      }
      
      allow get, list: if isSignedIn() && (isOwner() || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
      allow create: if isSignedIn() && isOwner() && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isOwner() && resource.data.userId == userId && resource != null;
      allow delete: if isSignedIn() && isOwner() && resource != null;
    }

    /**
     * @description Controls access to the draws collection.
     * @path /draws/{drawId}
     * @principle Allows any authenticated user to read the list of draws, but prevents any client from writing.
     * Writes should be handled by a secure backend/admin environment.
     */
    match /draws/{drawId} {
      allow get, list: if isSignedIn();
      allow write: if false; // Disallow client-side writes for draws
    }

     /**
     * @description Controls access to the configs collection.
     * @path /configs/{configId}
     * @principle Allows any authenticated user to read configurations, but prevents any client from writing.
     */
    match /configs/{configId} {
        allow get: if isSignedIn();
        allow write: if false;
    }
    
    /**
     * @description Controls access to the sellerHistory collection.
     * @path /sellerHistory/{historyId}
     * @principle Allows a seller to read their own history entries.
     */
    match /sellerHistory/{historyId} {
        allow get, list: if isSignedIn() && (
          (request.query.where.field == 'sellerId' && request.query.where.value == request.auth.uid) ||
          (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        );
        allow write: if false;
    }
    
    /**
     * @description Controls access to the adminHistory collection.
     * @path /adminHistory/{historyId}
     * @principle Disallows direct client access. Should be accessed via a secure backend.
     */
    match /adminHistory/{historyId} {
        allow read: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
        allow write: if false;
    }

     /**
     * @description Controls access to the tickets collection (for queries).
     * @path /tickets/{ticketId}
     * @principle This allows queries on the top-level tickets collection, scoped by buyerId or sellerId.
     */
    match /tickets/{ticketId} {
       allow read: if isSignedIn() && (
          (request.query.where.field == 'buyerId' && request.query.where.value == request.auth.uid) ||
          (request.query.where.field == 'sellerId' && request.query.where.value == request.auth.uid) ||
          (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
       );
       allow write: if false; // Direct writes to the root collection are disallowed. Use user-specific subcollections.
    }
  }
}
